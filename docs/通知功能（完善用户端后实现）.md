# 工单订阅消息通知功能设计文档

## 📋 概述

本文档描述微信小程序IT工程师工作台的订阅消息通知功能设计方案。系统分为**用户端**和**工程师端**两个独立的小程序，针对不同角色提供差异化的通知服务。

## 🎯 功能目标

### 用户端（创建工单方）
1. **工单完成通知**：工单已解决，邀请用户评价
2. **工单关闭通知**：工单已关闭，流程结束
3. **处理进度通知**：工单处理的重要节点更新（可选）

### 工程师端（处理工单方）
1. **新工单通知**：有新工单进入工单池
2. **紧急工单通知**：高优先级工单提醒
3. **经理通知**：经理发布的公告、任务分配等
4. **工单分配通知**：经理指定工单给特定工程师

## 🏗 系统架构

### 1. 整体流程

#### 用户端流程
```
工程师解决工单
    ↓
更新工单状态为已解决
    ↓
触发通知云函数
    ↓
发送完成通知给用户
    ↓
用户收到通知并评价
```

#### 工程师端流程
```
用户创建工单
    ↓
工单进入工单池
    ↓
触发通知云函数
    ↓
筛选在线工程师
    ↓
发送新工单通知
    ↓
工程师查看并接单
```

### 2. 核心组件

#### 2.1 用户端组件
- **订阅管理器** (`/user-miniprogram/utils/subscription-manager.js`)
  - 在创建工单时请求订阅
  - 管理用户订阅状态
  - 缓存订阅偏好

- **评价页面集成** (`/user-miniprogram/pages/ticket-evaluate/`)
  - 接收完成通知后跳转
  - 提交评价和反馈

#### 2.2 工程师端组件
- **订阅管理器** (`/engineer-miniprogram/utils/subscription-manager.js`)
  - 在登录时请求订阅
  - 管理工程师订阅状态
  - 处理通知偏好设置

- **通知设置页面** (`/engineer-miniprogram/pages/notification-settings/`)
  - 订阅开关管理
  - 通知类型筛选
  - 免打扰时段设置

#### 2.3 云函数
- **notifyUser** (`/cloudfunctions/notifyUser/`)
  - 向用户发送工单完成/关闭通知
  - 管理用户通知队列
  
- **notifyEngineer** (`/cloudfunctions/notifyEngineer/`)
  - 向工程师发送新工单通知
  - 处理经理通知分发
  - 管理工程师通知队列

- **改造 submitTicket**
  - 工单状态变更时触发相应通知
  - 区分用户端和工程师端通知

### 3. 数据库设计

**新增集合：user_subscriptions（用户端订阅）**
```javascript
{
  _id: String,
  openid: String,              // 用户openid
  userType: 'customer',       // 用户类型：customer
  templateIds: {               // 订阅的模板ID
    ticketComplete: String,    // 工单完成通知模板
    ticketClose: String,       // 工单关闭通知模板
    progressUpdate: String     // 进度更新模板（可选）
  },
  enabled: Boolean,            // 总开关
  preferences: {               // 通知偏好设置
    completeNotify: Boolean,   // 接收完成通知
    closeNotify: Boolean,      // 接收关闭通知
    progressNotify: Boolean    // 接收进度通知
  },
  subscribeTime: Date,         // 订阅时间
  lastNotifyTime: Date,        // 最后通知时间
  notifyCount: Number          // 通知次数统计
}
```

**新增集合：engineer_subscriptions（工程师端订阅）**
```javascript
{
  _id: String,
  openid: String,              // 工程师openid
  userType: 'engineer',        // 用户类型：engineer/manager
  roleGroup: String,           // 角色：工程师/经理
  templateIds: {               // 订阅的模板ID
    newTicket: String,         // 新工单通知模板
    urgentTicket: String,      // 紧急工单模板
    managerNotice: String,     // 经理通知模板
    assignTicket: String       // 指派工单模板
  },
  enabled: Boolean,            // 总开关
  preferences: {               // 通知偏好设置
    newTicket: Boolean,        // 接收新工单通知
    urgentOnly: Boolean,       // 仅接收紧急工单
    managerNotice: Boolean,    // 接收经理通知
    assignNotify: Boolean,     // 接收指派通知
    nightMode: Boolean,        // 夜间免打扰（22:00-8:00）
    workingHoursOnly: Boolean  // 仅工作时间（9:00-18:00）
  },
  workSchedule: {              // 工作时间表
    monday: Boolean,
    tuesday: Boolean,
    wednesday: Boolean,
    thursday: Boolean,
    friday: Boolean,
    saturday: Boolean,
    sunday: Boolean
  },
  subscribeTime: Date,         // 订阅时间
  lastNotifyTime: Date,        // 最后通知时间
  notifyCount: Number,         // 通知次数统计
  dailyLimit: Number           // 每日通知上限（默认20）
}
```

**新增集合：manager_announcements（经理公告）**
```javascript
{
  _id: String,
  title: String,               // 公告标题
  content: String,             // 公告内容
  priority: String,            // 优先级：high/normal/low
  targetGroups: Array,         // 目标群组：['all', 'engineer', 'specific']
  targetOpenids: Array,        // 特定目标（当targetGroups包含specific时）
  creatorOpenid: String,       // 创建者（经理）openid
  createTime: Date,            // 创建时间
  sendTime: Date,              // 发送时间
  status: String,              // 状态：draft/sent/cancelled
  notifyCount: Number,         // 已通知人数
  readCount: Number            // 已读人数
}
```

## 📝 详细设计

### 1. 订阅消息模板配置

需要在微信公众平台为两个小程序分别申请模板：

#### 用户端模板

**模板1：工单完成通知**
```
标题：您的工单已完成
内容：
工单编号：{{character_string1.DATA}}
完成时间：{{time2.DATA}}
处理工程师：{{name3.DATA}}
处理结果：{{thing4.DATA}}
温馨提示：{{thing5.DATA}} （请对本次服务进行评价）
```

**模板2：工单关闭通知**
```
标题：工单已关闭
内容：
工单编号：{{character_string1.DATA}}
关闭时间：{{time2.DATA}}
工单标题：{{thing3.DATA}}
最终状态：{{phrase4.DATA}}
备注说明：{{thing5.DATA}}
```

#### 工程师端模板

**模板1：新工单通知**
```
标题：新工单待处理
内容：
工单编号：{{character_string1.DATA}}
问题类型：{{thing2.DATA}}
优先级：{{phrase3.DATA}}
提交时间：{{time4.DATA}}
问题描述：{{thing5.DATA}}
```

**模板2：紧急工单通知**
```
标题：紧急工单提醒
内容：
工单编号：{{character_string1.DATA}}
紧急程度：{{phrase2.DATA}}
问题标题：{{thing3.DATA}}
提交人：{{name4.DATA}}
位置信息：{{thing5.DATA}}
```

**模板3：经理通知**
```
标题：管理通知
内容：
通知标题：{{thing1.DATA}}
发布时间：{{time2.DATA}}
优先级：{{phrase3.DATA}}
发布人：{{name4.DATA}}
通知内容：{{thing5.DATA}}
```

### 2. 前端实现

#### 2.1 用户端实现

##### 订阅管理器
```javascript
// user-miniprogram/utils/subscription-manager.js
class UserSubscriptionManager {
  constructor() {
    this.templateIds = {
      ticketComplete: 'TEMPLATE_ID_1',  // 需替换为实际模板ID
      ticketClose: 'TEMPLATE_ID_2'
    };
  }
  
  // 在创建工单时请求订阅
  async requestOnCreate() {
    const cache = wx.getStorageSync('subscription_asked') || {};
    const lastAsk = cache.lastAskTime || 0;
    const daysSinceAsk = (Date.now() - lastAsk) / (1000 * 60 * 60 * 24);
    
    // 每7天最多询问一次
    if (daysSinceAsk < 7) return { subscribed: false };
    
    try {
      const res = await wx.requestSubscribeMessage({
        tmplIds: [this.templateIds.ticketComplete]
      });
      
      // 记录询问时间
      wx.setStorageSync('subscription_asked', {
        lastAskTime: Date.now(),
        status: res[this.templateIds.ticketComplete]
      });
      
      return { subscribed: res[this.templateIds.ticketComplete] === 'accept' };
    } catch (err) {
      console.error('[订阅请求失败]', err);
      return { subscribed: false };
    }
  }
}
```

##### 创建工单页面集成
```javascript
// user-miniprogram/pages/ticket-create/index.js
async submitTicket() {
  // 智能请求订阅
  const subManager = new UserSubscriptionManager();
  await subManager.requestOnCreate();
  
  // 提交工单
  const result = await wx.cloud.callFunction({
    name: 'submitTicket',
    data: {
      action: 'submit',
      ticketData: this.data.formData,
      userOpenid: this.data.userOpenid
    }
  });
  
  // 提示用户
  wx.showToast({
    title: '工单已提交',
    icon: 'success'
  });
}
```

#### 2.2 工程师端实现

##### 订阅管理器
```javascript
// engineer-miniprogram/utils/subscription-manager.js
class EngineerSubscriptionManager {
  constructor() {
    this.templateIds = {
      newTicket: 'TEMPLATE_ID_3',      // 需替换为实际模板ID
      urgentTicket: 'TEMPLATE_ID_4',
      managerNotice: 'TEMPLATE_ID_5'
    };
  }
  
  // 在登录时请求订阅（工程师/经理）
  async requestOnLogin(roleGroup) {
    if (roleGroup === '用户') return { subscribed: false };
    
    const cache = wx.getStorageSync('eng_subscription') || {};
    const lastAsk = cache.lastAskTime || 0;
    const daysSinceAsk = (Date.now() - lastAsk) / (1000 * 60 * 60 * 24);
    
    // 每30天询问一次
    if (daysSinceAsk < 30 && cache.status === 'accept') {
      return { subscribed: true, cached: true };
    }
    
    try {
      const templates = [this.templateIds.newTicket];
      if (roleGroup === '经理') {
        templates.push(this.templateIds.managerNotice);
      }
      
      const res = await wx.requestSubscribeMessage({
        tmplIds: templates
      });
      
      // 保存订阅状态到云端
      await this.saveToCloud(res, roleGroup);
      
      return { subscribed: true };
    } catch (err) {
      console.error('[订阅请求失败]', err);
      return { subscribed: false };
    }
  }
  
  // 保存到云端数据库
  async saveToCloud(subscriptionResult, roleGroup) {
    const db = wx.cloud.database();
    const openid = wx.getStorageSync('openid');
    
    await db.collection('engineer_subscriptions').doc(openid).set({
      data: {
        openid: openid,
        roleGroup: roleGroup,
        templateIds: this.templateIds,
        enabled: true,
        preferences: {
          newTicket: subscriptionResult[this.templateIds.newTicket] === 'accept',
          urgentOnly: false,
          nightMode: true,
          workingHoursOnly: false
        },
        subscribeTime: new Date(),
        notifyCount: 0
      }
    });
  }
}
```

##### 登录页面集成
```javascript
// engineer-miniprogram/pages/login/index.js
async onLoginSuccess(userInfo) {
  // 工程师或经理登录后请求订阅
  if (userInfo.roleGroup !== '用户') {
    const subManager = new EngineerSubscriptionManager();
    await subManager.requestOnLogin(userInfo.roleGroup);
  }
  
  // 跳转到主页
  wx.switchTab({
    url: '/pages/dashboard/index'
  });
}

```

### 3. 云函数实现

#### 3.1 notifyUser 云函数（用户端通知）

```javascript
// cloudfunctions/notifyUser/index.js
const cloud = require('wx-server-sdk');
cloud.init();

const db = cloud.database();

exports.main = async (event, context) => {
  const { action, ticketData } = event;
  
  switch(action) {
    case 'ticketComplete':
      return await notifyTicketComplete(ticketData);
    case 'ticketClose':
      return await notifyTicketClose(ticketData);
    default:
      return { success: false, error: 'Unknown action' };
  }
};

// 通知工单完成
async function notifyTicketComplete(ticket) {
  try {
    // 获取用户订阅信息
    const subInfo = await db.collection('user_subscriptions')
      .where({ openid: ticket.openid })
      .get();
    
    if (!subInfo.data.length || !subInfo.data[0].enabled) {
      return { success: false, reason: 'User not subscribed' };
    }
    
    const sub = subInfo.data[0];
    const templateId = sub.templateIds.ticketComplete;
    
    // 发送订阅消息
    const result = await cloud.openapi.subscribeMessage.send({
      touser: ticket.openid,
      templateId: templateId,
      page: `pages/ticket-evaluate/index?id=${ticket._id}`,
      data: {
        character_string1: { value: ticket.ticketNo },
        time2: { value: formatTime(ticket.resolveTime) },
        name3: { value: ticket.assigneeName || '工程师' },
        thing4: { value: truncate(ticket.solution || '问题已解决', 20) },
        thing5: { value: '请对本次服务进行评价' }
      },
      miniprogramState: 'developer' // 生产环境改为 'formal'
    });
    
    // 更新通知记录
    await updateNotifyRecord(ticket.openid, 'complete');
    
    return { success: true };
  } catch (err) {
    console.error('[通知失败]', err);
    return { success: false, error: err.message };
  }
}

// 辅助函数
function formatTime(date) {
  const d = new Date(date);
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
}

function truncate(str, len) {
  return str.length > len ? str.substring(0, len - 3) + '...' : str;
}
```

#### 3.2 notifyEngineer 云函数（工程师端通知）

```javascript
// cloudfunctions/notifyEngineer/index.js
const cloud = require('wx-server-sdk');
cloud.init();

const db = cloud.database();

exports.main = async (event, context) => {
  const { action, ticketData, announcement } = event;
  
  switch(action) {
    case 'newTicket':
      return await notifyNewTicket(ticketData);
    case 'urgentTicket':
      return await notifyUrgentTicket(ticketData);
    case 'managerNotice':
      return await notifyManagerNotice(announcement);
    default:
      return { success: false, error: 'Unknown action' };
  }
};

// 通知新工单
async function notifyNewTicket(ticket) {
  try {
    // 获取所有订阅的工程师
    const engineers = await getSubscribedEngineers();
    
    // 过滤条件
    const filtered = engineers.filter(eng => {
      // 检查是否启用
      if (!eng.enabled || !eng.preferences.newTicket) return false;
      
      // 检查是否只接收紧急工单
      if (eng.preferences.urgentOnly && ticket.priority !== 'urgent') return false;
      
      // 检查免打扰时段
      if (eng.preferences.nightMode && isNightTime()) return false;
      
      // 检查工作时间
      if (eng.preferences.workingHoursOnly && !isWorkingHours()) return false;
      
      return true;
    });
    
    // 批量发送通知
    const results = await Promise.all(
      filtered.map(eng => sendNewTicketNotify(eng, ticket))
    );
    
    const successCount = results.filter(r => r.success).length;
    console.log(`[新工单通知] 成功发送 ${successCount}/${filtered.length} 条`);
    
    return { success: true, notified: successCount };
  } catch (err) {
    console.error('[通知新工单失败]', err);
    return { success: false, error: err.message };
  }
}

// 发送新工单通知
async function sendNewTicketNotify(engineer, ticket) {
  try {
    const templateId = engineer.templateIds.newTicket;
    
    await cloud.openapi.subscribeMessage.send({
      touser: engineer.openid,
      templateId: templateId,
      page: `pages/ticket-detail/index?id=${ticket._id}`,
      data: {
        character_string1: { value: ticket.ticketNo },
        thing2: { value: ticket.category || '未分类' },
        phrase3: { value: getPriorityText(ticket.priority) },
        time4: { value: formatTime(ticket.createTime) },
        thing5: { value: truncate(ticket.description, 20) }
      },
      miniprogramState: 'developer'
    });
    
    // 更新发送记录
    await updateEngineerNotifyCount(engineer.openid);
    
    return { success: true };
  } catch (err) {
    console.error(`[发送失败] ${engineer.openid}:`, err);
    return { success: false, error: err.message };
  }
}

// 获取订阅的工程师
async function getSubscribedEngineers() {
  const result = await db.collection('engineer_subscriptions')
    .where({
      enabled: true,
      roleGroup: db.command.in(['工程师', '经理'])
    })
    .get();
  
  return result.data;
}

// 辅助函数
function isNightTime() {
  const hour = new Date().getHours();
  return hour >= 22 || hour < 8;
}

function isWorkingHours() {
  const now = new Date();
  const hour = now.getHours();
  const day = now.getDay();
  
  // 周一到周五，9:00-18:00
  return day >= 1 && day <= 5 && hour >= 9 && hour < 18;
}

function getPriorityText(priority) {
  const map = {
    urgent: '紧急',
    high: '高',
    medium: '中',
    low: '低'
  };
  return map[priority] || '普通';
}
```

#### 3.3 改造 submitTicket 云函数

```javascript
// cloudfunctions/submitTicket/index.js
// 在现有函数中添加通知逻辑

// 工单创建后通知工程师
case 'submit':
  // ... 现有创建工单逻辑
  const newTicket = { /* 新创建的工单数据 */ };
  
  // 异步触发工程师通知（不影响主流程）
  cloud.callFunction({
    name: 'notifyEngineer',
    data: {
      action: ticket.priority === 'urgent' ? 'urgentTicket' : 'newTicket',
      ticketData: newTicket
    }
  }).then(res => {
    console.log('[通知工程师结果]', res);
  }).catch(err => {
    console.error('[通知工程师失败]', err);
  });
  
  return { success: true, ticketId: result._id };

// 工单完成后通知用户
case 'updateStatus':
  // ... 现有更新状态逻辑
  
  if (event.status === 'resolved') {
    // 异步触发用户通知
    cloud.callFunction({
      name: 'notifyUser',
      data: {
        action: 'ticketComplete',
        ticketData: updatedTicket
      }
    }).then(res => {
      console.log('[通知用户结果]', res);
    }).catch(err => {
      console.error('[通知用户失败]', err);
    });
  }
  
  return { success: true };
```

### 4. 通知设置页面（工程师端）

```xml
<!-- engineer-miniprogram/pages/notification-settings/index.wxml -->
<view class="settings-container">
  <t-cell-group title="订阅状态">
    <t-cell title="订阅消息" note="{{subscribeStatus}}">
      <t-switch 
        slot="note" 
        value="{{subscribed}}" 
        bind:change="toggleSubscription"
      />
    </t-cell>
  </t-cell-group>
  
  <t-cell-group title="通知类型" wx:if="{{subscribed}}">
    <t-cell title="新工单通知">
      <t-switch 
        slot="note" 
        value="{{preferences.newTicket}}" 
        bind:change="updatePreference"
        data-key="newTicket"
      />
    </t-cell>
    
    <t-cell title="仅紧急工单">
      <t-switch 
        slot="note" 
        value="{{preferences.urgentOnly}}" 
        bind:change="updatePreference"
        data-key="urgentOnly"
      />
    </t-cell>
    
    <t-cell title="经理通知" wx:if="{{roleGroup !== '工程师'}}">
      <t-switch 
        slot="note" 
        value="{{preferences.managerNotice}}" 
        bind:change="updatePreference"
        data-key="managerNotice"
      />
    </t-cell>
    
    <t-cell title="工单指派通知">
      <t-switch 
        slot="note" 
        value="{{preferences.assignNotify}}" 
        bind:change="updatePreference"
        data-key="assignNotify"
      />
    </t-cell>
  </t-cell-group>
  
  <t-cell-group title="免打扰设置" wx:if="{{subscribed}}">
    <t-cell title="夜间免打扰" note="22:00 - 08:00">
      <t-switch 
        slot="note" 
        value="{{preferences.nightMode}}" 
        bind:change="updatePreference"
        data-key="nightMode"
      />
    </t-cell>
    
    <t-cell title="仅工作时间" note="周一至周五 9:00-18:00">
      <t-switch 
        slot="note" 
        value="{{preferences.workingHoursOnly}}" 
        bind:change="updatePreference"
        data-key="workingHoursOnly"
      />
    </t-cell>
  </t-cell-group>
  
  <view class="stats" wx:if="{{subscribed}}">
    <text class="stats-title">通知统计</text>
    <view class="stats-item">
      <text>今日已接收：{{todayCount}} 条</text>
      <text>累计接收：{{totalCount}} 条</text>
    </view>
  </view>
  
  <view class="tips">
    <text>提示：</text>
    <text>• 订阅消息需要您主动确认</text>
    <text>• 一次订阅可收到一条通知</text>
    <text>• 建议定期重新订阅以持续接收通知</text>
  </view>
</view>
```

### 5. 经理公告功能（工程师端）

```xml
<!-- engineer-miniprogram/pages/manager-announce/index.wxml -->
<view class="announce-container">
  <view class="announce-form">
    <t-input 
      label="公告标题" 
      value="{{title}}" 
      bind:change="onTitleChange"
      placeholder="请输入公告标题"
    />
    
    <t-textarea
      label="公告内容"
      value="{{content}}"
      bind:change="onContentChange"
      placeholder="请输入公告内容"
      maxlength="200"
    />
    
    <t-cell title="优先级">
      <t-radio-group 
        slot="note"
        value="{{priority}}" 
        bind:change="onPriorityChange"
      >
        <t-radio value="high" label="高" />
        <t-radio value="normal" label="普通" />
        <t-radio value="low" label="低" />
      </t-radio-group>
    </t-cell>
    
    <t-cell title="接收对象">
      <t-checkbox-group 
        slot="note"
        value="{{targetGroups}}" 
        bind:change="onTargetChange"
      >
        <t-checkbox value="all" label="全部工程师" />
        <t-checkbox value="online" label="在线工程师" />
        <t-checkbox value="specific" label="指定人员" />
      </t-checkbox-group>
    </t-cell>
    
    <view class="button-group">
      <t-button theme="primary" block bind:tap="sendAnnouncement">
        发送公告
      </t-button>
    </view>
  </view>
  
  <view class="history-list">
    <t-cell-group title="历史公告">
      <t-cell 
        wx:for="{{historyList}}" 
        wx:key="_id"
        title="{{item.title}}"
        note="{{item.createTime}}"
        bind:tap="viewDetail"
        data-id="{{item._id}}"
      >
        <t-tag slot="note" theme="{{item.priority}}">
          {{item.notifyCount}}人已收到
        </t-tag>
      </t-cell>
    </t-cell-group>
  </view>
</view>
```

## 🔧 实施计划

### 第一阶段：基础准备（1天）
1. ✅ 设计文档编写
2. ⬜ 申请订阅消息模板
   - 用户端：2个模板（完成通知、关闭通知）
   - 工程师端：3个模板（新工单、紧急工单、经理通知）
3. ⬜ 创建数据库集合
   - user_subscriptions
   - engineer_subscriptions
   - manager_announcements

### 第二阶段：用户端开发（2天）
1. ⬜ 实现用户端 subscription-manager.js
2. ⬜ 创建 notifyUser 云函数
3. ⬜ 在工单创建页面集成订阅请求
4. ⬜ 创建评价页面（接收通知后跳转）
5. ⬜ 修改 submitTicket 云函数（完成时通知）

### 第三阶段：工程师端开发（3天）
1. ⬜ 实现工程师端 subscription-manager.js
2. ⬜ 创建 notifyEngineer 云函数
3. ⬜ 在登录页面集成订阅请求
4. ⬜ 创建通知设置页面
5. ⬜ 实现免打扰和过滤逻辑
6. ⬜ 修改 submitTicket 云函数（新工单通知）

### 第四阶段：经理功能（2天）
1. ⬜ 创建经理公告页面
2. ⬜ 实现公告发送云函数
3. ⬜ 集成经理通知模板
4. ⬜ 添加公告历史管理

### 第五阶段：测试优化（2天）
1. ⬜ 端到端测试
2. ⬜ 性能优化（批量发送、队列管理）
3. ⬜ 用户体验优化
4. ⬜ 文档更新

## 📊 预期效果

### 用户端
1. **服务体验提升**：用户能及时知道工单处理完成，方便评价
2. **流程透明化**：用户清楚工单的最终状态
3. **满意度提高**：通过评价反馈机制提升服务质量

### 工程师端
1. **响应速度提升**：新工单及时通知，预计响应时间缩短60%
2. **工作效率提高**：紧急工单优先处理，避免遗漏
3. **团队协作增强**：经理通知功能加强团队沟通
4. **灵活性增强**：个性化通知设置，避免打扰

## ⚠️ 注意事项

1. **两端分离**：用户端和工程师端是独立的小程序，需要分别申请模板
2. **用户授权**：订阅消息需要用户主动授权，不能强制
3. **次数限制**：一次订阅只能发送一条消息，需要合理设计请求时机
4. **模板审核**：每个小程序的模板需要单独审核，可能需要1-3个工作日
5. **AppID区分**：云函数中需要区分不同小程序的AppID
6. **测试环境**：开发时使用 `miniprogramState: 'developer'`，上线改为 `'formal'`
7. **隐私合规**：两个小程序都需要在隐私协议中说明消息通知用途

## 🔑 关键技术点

1. **多小程序管理**：
   - 用户端和工程师端使用不同的AppID
   - 云函数需要初始化对应的云环境
   - 模板ID需要分别管理

2. **订阅策略**：
   - 用户端：在创建工单时请求，低频询问
   - 工程师端：在登录时请求，定期刷新

3. **通知过滤**：
   - 时间过滤：夜间免打扰、工作时间
   - 优先级过滤：仅紧急工单
   - 角色过滤：区分工程师和经理

4. **性能优化**：
   - 批量发送：使用Promise.all并发
   - 失败重试：记录失败日志，定时重试
   - 限流控制：避免超过API调用限制

## 🔄 后续优化方向

### 短期优化（1-2月）
1. **消息聚合**：多个工单聚合为一条摘要通知
2. **智能推送**：根据工程师在线状态和工作负载智能分配
3. **通知统计**：完善通知效果分析dashboard

### 中期优化（3-6月）
1. **AI智能分配**：根据工单内容和工程师专长自动匹配
2. **预测性通知**：基于历史数据预测工单高峰期
3. **多渠道通知**：集成企业微信、邮件等其他通知渠道

### 长期规划（6月+）
1. **语音通知**：重要工单支持语音播报
2. **视频通知**：复杂问题支持视频说明
3. **国际化支持**：多语言通知模板

## 📚 参考资料

### 微信官方文档
- [订阅消息功能介绍](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)
- [订阅消息开发指南](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html#%E5%BC%80%E5%8F%91%E5%89%8D%E5%BF%85%E8%AF%BB)
- [模板消息管理](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html#%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E7%AE%A1%E7%90%86)
- [订阅消息参数说明](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html)

### 云开发相关
- [云开发订阅消息API](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/openapi/subscribeMessage.html)
- [云函数发送订阅消息](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/open/subscribeMessage/Cloud.openapi.subscribeMessage.send.html)
- [订阅消息云调用](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/mp-message-management/subscribe-message/sendMessage.html)

### 最佳实践
- [订阅消息最佳实践](https://developers.weixin.qq.com/community/develop/article/doc/000c2449a7c3a8dd91fb1fceb5b813)
- [多端开发架构指南](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)
- [小程序消息推送配置](https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html)

### 相关限制和规范
- [订阅消息使用规则](https://developers.weixin.qq.com/miniprogram/product/subscribeMessage.html)
- [模板消息审核规范](https://developers.weixin.qq.com/miniprogram/product/subscribeMessage.html#%E5%AE%A1%E6%A0%B8%E8%A7%84%E8%8C%83)
- [API调用频率限制](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/api-frequency.html)

---

*文档创建时间：2025-08-18*
*最后更新：2025-08-18*
*作者：AI Assistant*
*状态：待审批*

## 修订记录
- v1.0 (2025-08-18): 初始设计，基于单一小程序架构
- v2.0 (2025-08-18): 重新设计，改为用户端和工程师端分离架构